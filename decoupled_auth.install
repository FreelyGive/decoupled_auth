<?php

/**
 * @file
 * Install, update and uninstall functions for the decoupled user authentication
 * module.
 */

/**
 * Implements hook_requirements().
 */
function decoupled_auth_requirements($phase) {
  $requirements = [];

  if ($phase == 'runtime') {
    $requirements['decoupled_auth_registration_acquisitions'] = [
      'title' => t('User registration acquisition verification'),
      'severity' => REQUIREMENT_OK,
      'description' => t('It is not recommended that user registration acquisitions are enabled without account verification such as email. This could allow malicious registrations to access data they should not be authorised to see.'),
    ];

    // If registration acquisitions are enabled but email verification is not,
    // we probably want to show a warning.
    if (Drupal::config('decoupled_auth.settings')->get('acquisitions.registration')) {
      if (!Drupal::config('user.settings')->get('verify_mail')) {
        // As other verification processes could be enabled, we allow this
        // message to be disabled.
        if (!Drupal::config('decoupled_auth.settings')->get('acquisitions.registration_notice_demote')) {
          $requirements['decoupled_auth_registration_acquisitions']['severity'] = REQUIREMENT_ERROR;
        }
        else {
          $requirements['decoupled_auth_registration_acquisitions']['severity'] = REQUIREMENT_WARNING;
        }
      }
    }
  }

  return $requirements;
}

/**
 * Implements hook_install().
 */
function decoupled_auth_install() {
  $manager = Drupal::entityDefinitionUpdateManager();

  // Get hold of our user type definition.
  $user_type = $manager->getEntityType('user');

  // Switch to our own class and inform the entity definition manager.
  $user_type->setClass('Drupal\decoupled_auth\Entity\DecoupledAuthUser');
  $user_type->setHandlerClass('storage_schema', 'Drupal\decoupled_auth\DecoupledAuthUserStorageSchema');
  $manager->updateEntityType($user_type);

  // Make name not required at a database level and swap the constraint.
  $name = $manager->getFieldStorageDefinition('name', 'user');
  $constraints = $name->getConstraints();
  unset($constraints['UserName']);
  unset($constraints['NotNull']);
  $constraints['DecoupledAuthUserName'] = array();
  $name
    ->setRequired(FALSE)
    ->setConstraints($constraints);

  // Make adjustments to mail.
  $mail = $manager->getFieldStorageDefinition('mail', 'user');
  $constraints = $mail->getConstraints();

  // Swap to our own unique constraint for mail.
  unset($constraints['UserMailUnique']);
  $constraints['DecoupledAuthUserMailUnique'] = array();

  // Swap to our own required constraint for mail.
  unset($constraints['UserMailRequired']);
  $constraints['DecoupledAuthUserMailRequired'] = array();

  $mail->setConstraints($constraints);

  $manager->updateFieldStorageDefinition($name);
}

/**
 * Implements hook_uninstall().
 */
function decoupled_auth_uninstall() {
  $manager = Drupal::entityDefinitionUpdateManager();

  // Get hold of our user type definition.
  $user_type = $manager->getEntityType('user');

  // Switch to our own class and inform the entity definition manager.
  $user_type->setClass('Drupal\user\Entity\User');
  $user_type->setHandlerClass('storage_schema', 'Drupal\user\UserStorageSchema');
  $manager->updateEntityType($user_type);

  // Revert our name changes.
  $name = $manager->getFieldStorageDefinition('name', 'user');
  $constraints = $name->getConstraints();
  unset($constraints['DecoupledAuthUserName']);
  $constraints['UserName'] = array();
  $constraints['NotNull'] = array();
  $name
    ->setRequired(FALSE)
    ->setConstraints($constraints);

  // Revert our mail changes.
  $mail = $manager->getFieldStorageDefinition('mail', 'user');
  $constraints = $mail->getConstraints();

  // Swap back the unique constraint.
  unset($constraints['DecoupledAuthUserMailUnique']);
  $constraints['UserMailUnique'] = array();

  // Swap back the required constraint.
  unset($constraints['DecoupledAuthUserMailRequired']);
  $constraints['UserMailRequired'] = array();

  $mail->setConstraints($constraints);

  $manager->updateFieldStorageDefinition($name);
}
